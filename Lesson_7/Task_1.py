"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. Обязательно доработайте алгоритм (сделайте его умнее).
Идея доработки: если за проход по списку не совершается ни одной сортировки, то завершение
Обязательно сделайте замеры времени обеих реализаций
Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию
"""


# Идея - продолжать сравнивать число, которое мы уже бросили в момент проверки (больше/меньше соседа).

from random import randint
import timeit


def func_bubble_sort(array):
    for n in range(len(array) - 1):
        y = 0
        for i in range(len(array) - 1):
            if array[i] < array[i + 1]:
                x = i
                array[i], array[i + 1] = array[i + 1], array[i]
                for _ in range(x, len(array) - 1):
                    if array[x] < array[x + 1]:
                        array[x], array[x + 1] = array[x + 1], array[x]
                        x += 1
                    else:
                        x += 1
            else:
                y += 1
        if y == (len(array) - 1):
            return array


SIZE = 10

a = [randint(-100, 100 - 1) for i in range(SIZE)]
print(a)
print(func_bubble_sort(a))

# print(timeit.timeit('func_bubble_sort(a)', number=100, globals=globals()))

# Текущий вариант с 3мя циклами (продолжаю сравнивать число в случае если его отпустили и перешли к другому,
# сократили число проходов), похоже на линейную сложность уже,
# но почему-то я ждал дольше чем timeit выдал (на 100 прогонах), заметил, что зависит от того где стоит return,
# например, если оставить return и поставить на уровень выше чем сейчас (уровень второго for),
# то timeit пишет, что алгоритм с 2 циклами быстрее)), поэтому статистика может быть недостоверной,
# но визуально все равно быстрее (10к я хотя бы дождался за 30с):

# 0.00033615299999999876 - 10
# 0.005210856 - 100
# 0.353111758 - 1000
# 32.680807417000004 - 10000

# Самый простой вариант (2 цикла):
# 0.0018189960000000033 - 10
# 0.197504901 - 100
# 18.570244589 - 1000
